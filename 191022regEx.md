# REGEX une introduction



##### Premiers principes
* /une regEx se trouve toujours entre 2 barres obliques/
* une regEx se place à droite de l'opérateur Perl `=~`
* Si la partie gauche correspond à la partie droite en regEx, l'opérateur renverra `1` et `0` sinon.

* En Perl, supposons que l'on place les lignes d'un fichier dans une liste nommée @lines. 

On écrira pour chercher si une ligne **est** la chaîne "From" : 
```
foreach $lignes (@lines) {
	if ($ligne =~ /From/) {Entrer dans une suite d'instructions}

```



##### Les symboles réservés et l'échappement
* Dans les regEx certains caractères sont réservés. 

Pour être affichés normalement, ils doivent être systématiquement échappés par un antislash `\`

```
           	
		^
		+
	   {  ( . )  }       
               [?]
              /   \
		|
		$

```



##### Le début et la fin d'une chaîne : `^` et `$`
* Les lignes qui **commencent par From**:  `/^From/`
* Les lignes qui **terminent par From**: `/From$/`



##### L'opérateur OR `|`
* Rechercher, pour chaque ligne, si elle commence OU par From OU par Date
```
foreach $lignes (@lines) {
	if ($ligne =~ /^(From|Date)/) {Entrer dans une suite d'instructions}
```



##### Faire une recherche en `i`gnorant la casse
* Repérons les lignes contenant From, en IGNORANT LA CASSE:
```
foreach $lignes (@lines) {
	if ($ligne =~ /From/i)   
```

Un inconvénient: froM et FRoM seront pris en compte dans la recherche.



##### Les unions (OR plus élaboré) avec les crochets `[ ]`
* Nous voulons repérer les lignes contenant From, mais ignorant la casse du SEUL PREMIER caractère.
```
foreach $lignes (@lines) {
	if ($ligne =~ /[Ff]rom/)
```



##### L'avantage des unions sur le OR : la possibilité des listes `[0-9]`
* Nous voulons repérer les lignes contenant un mot commençant par une majuscule.
```
foreach $lignes (@lines) {
	if ($ligne =~ /^[A-Z]/)
```



